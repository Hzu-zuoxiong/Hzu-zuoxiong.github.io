<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>騎豬兜風</title>
  
  <subtitle>什么都无法舍弃的人，什么也改变不了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hzu-zuoxiong.github.io/"/>
  <updated>2021-07-12T07:50:08.743Z</updated>
  <id>https://hzu-zuoxiong.github.io/</id>
  
  <author>
    <name>Hzu-zuoxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Action 自动打包部署 vue 项目到阿里云 OSS</title>
    <link href="https://hzu-zuoxiong.github.io/2021/07/12/Github-Action-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2-vue-%E9%A1%B9%E7%9B%AE%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91-OSS/"/>
    <id>https://hzu-zuoxiong.github.io/2021/07/12/Github-Action-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2-vue-%E9%A1%B9%E7%9B%AE%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91-OSS/</id>
    <published>2021-07-12T15:29:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>最近做了一个<a href="https://github.com/Hzu-zuoxiong/personalToolSet" target="_blank" rel="noopener">工具集</a>的 vue 项目，想要通过 Githuub Action 在每次 Push 代码的时候自动打包项目，并将其上传到阿里云的 OSS 里面，从而实现自动部署。 </p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>要想上传文件到阿里云 OSS，需要先在阿里云控制台中的访问控制里创建一个 AccessKey，拿到 AccessKey ID 和 AccessKey Secret 值。</p><p>拿到值后在仓库的 “Setting -&gt; Secrets” 中添加仓库秘钥</p><p><img src="http://picbed.wuzuoxiong.top/20210712_githubActionSecrets.png" alt></p><h2 id="编写-Github-workflow"><a href="#编写-Github-workflow" class="headerlink" title="编写 Github workflow"></a>编写 Github workflow</h2><p>在仓库的 Ation Tab 中新增一个 main.yml 文件，用于编写部署代码</p><p><img src="http://picbed.wuzuoxiong.top/20210712_githubWorkflow1.png" alt><br><img src="http://picbed.wuzuoxiong.top/20210712_githubWorkflow2.png" alt></p><p>关于 Github Action 的相关知识点可以参考阮一峰大佬的文章，文章链接在下方参考链接。</p><p>在 main.yml 中，我们先对 vue 项目进行打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: Run a multi-line script</span><br><span class="line">    run: |</span><br><span class="line">      npm install</span><br><span class="line">      npm run build:prod</span><br></pre></td></tr></table></figure><p>接着将打包好的文件上传到阿里云 OSS，需要注意以下几点配置：</p><ol><li>endpoint: 指的阿里云 OSS 的地域节点</li><li>access-key-id：配置在 Github secrets 里的 ID</li><li>access-key-secret：配置在 Github secrets 里的 secret</li><li>执行时会将指定文件夹内的文件拷贝至阿里云 OSS 指定的 Bucket 名称</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入 OSS 包</span></span><br><span class="line">- uses: manyuanrong/setup-ossutil@v2.0</span><br><span class="line">    with:</span><br><span class="line">      endpoint:  <span class="string">"oss-cn-beijing.aliyuncs.com"</span></span><br><span class="line">      access-key-id: <span class="variable">$&#123;&#123; secrets.ACCESS_KEY_ID &#125;</span>&#125;</span><br><span class="line">      access-key-secret: <span class="variable">$&#123;&#123; secrets.ACCESS_KEY_SECRET &#125;</span>&#125;</span><br><span class="line">- name: Deploy To OSS</span><br><span class="line">    run: ossutil cp &lt;指定文件夹&gt; oss://&lt;阿里云 OSS 指定的 Bucket 名称&gt;/ -rf</span><br></pre></td></tr></table></figure><p>具体细节可以参考 demo：<a href="https://github.com/Hzu-zuoxiong/personalToolSet/blob/master/.github/workflows/main.yml" target="_blank" rel="noopener">https://github.com/Hzu-zuoxiong/personalToolSet/blob/master/.github/workflows/main.yml</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>在 “基础设置 -&gt; 静态页面” 中设置默认首页</li><li>第一次上传到 OSS 之后，需要我们去手动修改下 index.html 文件的 Http 请求头，将 Content-Type 改为<br>text/html; charset=utf-8（若不改修改此处，访问域名时则是触发下载文件，而不是线上访问）</li></ol><p>完成以上两步后，我们就可以通过访问 Bucket 域名访问到我们部署的项目了。<br><img src="http://picbed.wuzuoxiong.top/20210712_githubWorkflow3.png" alt><br><img src="http://picbed.wuzuoxiong.top/20210712_githubWorkflow4.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li>Github Action 入门教程： <a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;最近做了一个&lt;a href=&quot;https://github.com/Hzu-zuoxiong/personalToolSet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工具集&lt;/a&gt;的 vue 项目，想要通过 Githuub Action 在每次 Push 代码的时候自动打包项目，并将其上传到阿里云的 OSS 里面，从而实现自动部署。 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Github Action" scheme="https://hzu-zuoxiong.github.io/tags/Github-Action/"/>
    
  </entry>
  
  <entry>
    <title>canvas 实现图片放大镜效果</title>
    <link href="https://hzu-zuoxiong.github.io/2021/07/09/canvas-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C/"/>
    <id>https://hzu-zuoxiong.github.io/2021/07/09/canvas-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C/</id>
    <published>2021-07-09T19:31:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>之前在公司工作接到图片放大镜的需求，记录一下其中的实现过程和细节。具体需求如下：</p><ol><li>普通图片可正常使用图片预览，缩放拖拽与放大镜功能</li><li>存在标点位置信息的图片可对其位置进行标点，且缩放后位置不会变动</li></ol><a id="more"></a><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://picbed.wuzuoxiong.top/20210709_pictureMagnifier.png" alt></p><p>线上 demo 演示：<a href="http://toolset.wuzuoxiong.top/#/picMagnifier/index" target="_blank" rel="noopener">http://toolset.wuzuoxiong.top/#/picMagnifier/index</a></p><p>线上 demo 源码：<a href="https://github.com/Hzu-zuoxiong/personalToolSet/blob/master/src/views/picMagnifier/img-viewer/index.vue" target="_blank" rel="noopener">https://github.com/Hzu-zuoxiong/personalToolSet/blob/master/src/views/picMagnifier/img-viewer/index.vue</a></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-绘制背景图片"><a href="#1-绘制背景图片" class="headerlink" title="1. 绘制背景图片"></a>1. 绘制背景图片</h3><p>使用 canvas 绘制图片，将其作为背景图，img 标签主要用于预加载图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas</span><br><span class="line">  ref=<span class="string">"canvas"</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span></span>=<span class="string">"canvas"</span></span><br><span class="line">  @mousemove=<span class="string">"mousemove"</span></span><br><span class="line">  @mousedown=<span class="string">"mousedown"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;img</span><br><span class="line">  v-show=<span class="string">"false"</span></span><br><span class="line">  ref=<span class="string">"img"</span></span><br><span class="line">  :src=<span class="string">"img.picUrl"</span></span><br><span class="line">  @load=<span class="string">"drawBackGround"</span> &gt;</span><br></pre></td></tr></table></figure><p>在绘制图片之前，需要先根据图片大小确定 canvas 宽高，若一开始给 canvas 标签定死宽高则会对部分图片造成拉伸效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制图片背景</span></span><br><span class="line">drawBackGround() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; canvas, img &#125; = <span class="keyword">this</span>.$refs</span><br><span class="line">  <span class="comment">// 纵向长图</span></span><br><span class="line">  <span class="keyword">if</span> (img.naturalHeight &gt;= img.naturalWidth) &#123;</span><br><span class="line">    <span class="comment">// 最大高度 850，宽度等比例缩放</span></span><br><span class="line">    <span class="keyword">if</span> (img.naturalHeight &gt; <span class="number">850</span>) &#123;</span><br><span class="line">      canvas.height = <span class="number">850</span></span><br><span class="line">      canvas.width = canvas.height * (img.naturalWidth / img.naturalHeight)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      canvas.height = img.naturalHeight</span><br><span class="line">      canvas.width = img.naturalWidth</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 横向长图</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (img.naturalWidth &gt; img.naturalHeight) &#123;</span><br><span class="line">    <span class="comment">// 最大宽度 1200， 高度等比例缩放</span></span><br><span class="line">    <span class="keyword">if</span> (img.naturalWidth &gt; <span class="number">1200</span>) &#123;</span><br><span class="line">      canvas.width = <span class="number">1200</span></span><br><span class="line">      canvas.height = canvas.width / (img.naturalWidth / img.naturalHeight)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      canvas.height = img.naturalHeight</span><br><span class="line">      canvas.width = img.naturalWidth</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.context.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">  <span class="keyword">this</span>.context.fillStyle = <span class="string">'#FFFFFF'</span></span><br><span class="line">  <span class="keyword">this</span>.context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">  <span class="keyword">this</span>.context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="2-绘制图片标点位置"><a href="#2-绘制图片标点位置" class="headerlink" title="2. 绘制图片标点位置"></a>2. 绘制图片标点位置</h3><p>在绘制标点位置信息之前需要先确定 canvas 横向纵向缩放倍率，计算倍率之后重新计算需要标点的位置信息，再进行绘制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">drawEPCPoint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.img.picPosition) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> &#123; canvas, img &#125; = <span class="keyword">this</span>.$refs</span><br><span class="line">  <span class="comment">// 图片横向缩放</span></span><br><span class="line">  <span class="keyword">const</span> widthScale = canvas.width / img.naturalWidth</span><br><span class="line">  <span class="comment">// 图片纵向缩放</span></span><br><span class="line">  <span class="keyword">const</span> heightScale = canvas.height / img.naturalHeight</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    topLeftX, topLeftY, bottomRightX, bottomRightY</span><br><span class="line">  &#125; = <span class="keyword">this</span>.img</span><br><span class="line">  <span class="comment">// 打点标记的左上角、宽高值</span></span><br><span class="line">  <span class="keyword">const</span> realTopLeftX = widthScale * topLeftX</span><br><span class="line">  <span class="keyword">const</span> realTopLeftY = heightScale * topLeftY</span><br><span class="line">  <span class="keyword">const</span> pointWidth = (bottomRightX - topLeftX) * widthScale</span><br><span class="line">  <span class="keyword">const</span> pointHeight = (bottomRightY - topLeftY) * heightScale</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.context.fillStyle = <span class="string">'rgba(0, 255, 255, 0.4)'</span></span><br><span class="line">  <span class="keyword">this</span>.context.fillRect(realTopLeftX, realTopLeftY, pointWidth, pointHeight)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="3-绘制放大镜"><a href="#3-绘制放大镜" class="headerlink" title="3. 绘制放大镜"></a>3. 绘制放大镜</h3><p>当鼠标在 canvas 移动时，触发 mousemove 事件，这时绘制放大镜需要做以下几点：</p><ol><li>计算鼠标相对于画布的距离。鼠标事件获得的坐标为屏幕的坐标，需要减去画布距离屏幕的左侧与顶部，才能计算出鼠标相对于画布的距离<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">windowToCanvas(x, y) &#123;</span><br><span class="line">  <span class="keyword">const</span> bbox = <span class="keyword">this</span>.$refs.canvas.getBoundingClientRect()</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: x - bbox.left, <span class="attr">y</span>: y - bbox.top &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>在每次绘制放大镜之前，需要绘制背景图重新覆盖画布</li><li>计算需要放大的区域位置信息(放大镜半径两倍宽高)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calOriginalRectangle(point) &#123;</span><br><span class="line">  <span class="comment">// originalRectangle：图片被放大区域位置信息</span></span><br><span class="line">  <span class="comment">// originalRadius：放大镜半径</span></span><br><span class="line">  <span class="keyword">const</span> &#123; originalRectangle, originalRadius &#125; = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">Object</span>.assign(originalRectangle, &#123;</span><br><span class="line">    x: point.x - originalRadius,</span><br><span class="line">    y: point.y - originalRadius,</span><br><span class="line">    width: originalRadius * <span class="number">2</span>,</span><br><span class="line">    height: originalRadius * <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>绘制放大镜</li></ol><p>原理：只需要让被放大区域与放大区域中心点保持一致，把被放大区域的内容重新绘制到放大的区域，形成覆盖，再使用 clip 函数裁剪出一个圆形的区域。如下图所示：<br><img src="http://picbed.wuzuoxiong.top/20210709_magnifierPrinciple.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制放大镜</span></span><br><span class="line">drawMagnifyingGlass() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    originalRectangle, scale, centerPoint, context, originalRadius</span><br><span class="line">  &#125; = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; canvas &#125; = <span class="keyword">this</span>.$refs</span><br><span class="line">  <span class="comment">// 放大后的区域</span></span><br><span class="line">  <span class="keyword">const</span> scaleGlassRectangle = &#123;</span><br><span class="line">    x: centerPoint.x - originalRadius * scale,</span><br><span class="line">    y: centerPoint.y - originalRadius * scale,</span><br><span class="line">    width: originalRectangle.width * scale,</span><br><span class="line">    height: originalRectangle.height * scale</span><br><span class="line">  &#125;</span><br><span class="line">  context.save()</span><br><span class="line">  context.beginPath()</span><br><span class="line">  <span class="comment">// 绘制一个圆</span></span><br><span class="line">  context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>)</span><br><span class="line">  context.clip()</span><br><span class="line">  <span class="comment">// 绘制放大的区域</span></span><br><span class="line">  context.drawImage(canvas,</span><br><span class="line">    originalRectangle.x, originalRectangle.y,</span><br><span class="line">    originalRectangle.width, originalRectangle.height,</span><br><span class="line">    scaleGlassRectangle.x, scaleGlassRectangle.y,</span><br><span class="line">    scaleGlassRectangle.width, scaleGlassRectangle.height)</span><br><span class="line">  context.restore()</span><br><span class="line">  context.beginPath()</span><br><span class="line">  <span class="comment">// 绘制渐变色镜子框</span></span><br><span class="line">  <span class="keyword">const</span> gradient = context.createRadialGradient(</span><br><span class="line">    centerPoint.x, centerPoint.y, originalRadius - <span class="number">5</span>,</span><br><span class="line">    centerPoint.x, centerPoint.y, originalRadius</span><br><span class="line">  )</span><br><span class="line">  gradient.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,0,0.2)'</span>)</span><br><span class="line">  gradient.addColorStop(<span class="number">0.80</span>, <span class="string">'silver'</span>)</span><br><span class="line">  gradient.addColorStop(<span class="number">0.90</span>, <span class="string">'silver'</span>)</span><br><span class="line">  gradient.addColorStop(<span class="number">1.0</span>, <span class="string">'rgba(150,150,150,0.9)'</span>)</span><br><span class="line">  context.strokeStyle = gradient</span><br><span class="line">  context.lineWidth = <span class="number">5</span></span><br><span class="line">  context.arc(centerPoint.x, centerPoint.y, originalRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">false</span>)</span><br><span class="line">  context.stroke()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>拖拽与缩放都是通过 CSS 的 transform 与 zoom 进行的实现，实现较为简单，具体的实现细节可通过源码进行查看，这里暂不讲述</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>【HTML5】Canvas 实现放大镜效果<a href="https://www.cnblogs.com/zhangjk1993/p/5943989.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangjk1993/p/5943989.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;之前在公司工作接到图片放大镜的需求，记录一下其中的实现过程和细节。具体需求如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通图片可正常使用图片预览，缩放拖拽与放大镜功能&lt;/li&gt;
&lt;li&gt;存在标点位置信息的图片可对其位置进行标点，且缩放后位置不会变动&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="canvas" scheme="https://hzu-zuoxiong.github.io/tags/canvas/"/>
    
      <category term="toolset" scheme="https://hzu-zuoxiong.github.io/tags/toolset/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://hzu-zuoxiong.github.io/2021/04/25/Promise/"/>
    <id>https://hzu-zuoxiong.github.io/2021/04/25/Promise/</id>
    <published>2021-04-25T14:03:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<p>三种状态：</p><ul><li>已成功：fulfilled</li><li>进行中：pending</li><li>已失败：rejected</li></ul><p>Promise 对象的状态改变，只有两种可能：从 pending -&gt; fulfilled 和从pending -&gt; rejected。</p><a id="more"></a><p>如果 Promise 状态已经变成 resolved，再抛出错误是无效的,因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。例如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 跟传统的 try/catch 代码块不同的是，如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即 Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”</p><h3 id="Promise-prototype-finally-ES9引入"><a href="#Promise-prototype-finally-ES9引入" class="headerlink" title="Promise.prototype.finally (ES9引入)"></a>Promise.prototype.finally (ES9引入)</h3><ul><li>finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li><li>finally 方法总是会返回原来的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all() 方法接受一个数组作为参数，参数数组中每个元素都都是 Promise 实例，如果不是，就会先调用 Promise.resolve 方法将参数转为 Promise 实例。另外，Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p>Promise.all 的状态变化分成两种情况：</p><ul><li>只有参数数组每个元素的状态都变成 fulfilled，Promise.all 的状态才会变成 fulfilled，此时数组每个元素的返回值组成一个数组，传递给下一层。</li><li>只要参数数组的元素中有一个被 rejected，此时 Promise.all 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，传递给下一层。</li></ul><p>如果作为参数的 Promise 实例，自己定义了catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch 方法。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race() 方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数数组中有一个 Promise 实例率先改变状态，Promise.race 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递下一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定时间内没有获得结果，就将 Promise 的状态变为 reject，否则变为 resolve。</span></span><br><span class="line">p.then(<span class="built_in">console</span>.log)</span><br><span class="line"> .catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled-ES11引入"><a href="#Promise-allSettled-ES11引入" class="headerlink" title="Promise.allSettled (ES11引入)"></a>Promise.allSettled (ES11引入)</h3><p>Promise.allSettled() 方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。一旦结束，状态总是 fulfilled，不会变成 rejected。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: 'fulfilled', value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: 'rejected', reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h3 id="promise-any-ES12引入"><a href="#promise-any-ES12引入" class="headerlink" title="promise.any (ES12引入)"></a>promise.any (ES12引入)</h3><p>Promise.any 方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</p><p>Promise.any 跟 Promise.race 方法很像，只有一点不同，就是不会因为某个 Promise 变成 rejected 状态而结束。</p><p>Promise.any 抛出的错误，是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被 rejected 的操作所抛出的错误。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰ES6入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已成功：fulfilled&lt;/li&gt;
&lt;li&gt;进行中：pending&lt;/li&gt;
&lt;li&gt;已失败：rejected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Promise 对象的状态改变，只有两种可能：从 pending -&amp;gt; fulfilled 和从pending -&amp;gt; rejected。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试题" scheme="https://hzu-zuoxiong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="ES6" scheme="https://hzu-zuoxiong.github.io/tags/ES6/"/>
    
      <category term="js基础" scheme="https://hzu-zuoxiong.github.io/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://hzu-zuoxiong.github.io/2021/04/06/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://hzu-zuoxiong.github.io/2021/04/06/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-04-06T19:07:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>在很多场景会频繁触发事件或频繁向后台发送请求，从而引发性能问题甚至导致浏览器奔溃，例如鼠标滚动事件，鼠标移动事件，input框模糊查询等。</p><a id="more"></a><p><strong>防抖要做的就是短时间内触发同一个事件，只在开头或结尾执行一次</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用防抖，数字会疯狂地增长。</span></span><br><span class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doc.innerHTML = count++;</span><br><span class="line">&#125;</span><br><span class="line">doc.onmousemove = todo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用防抖，在最后执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">doc.onmousemove = debounce(todo, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>可控制开头或结尾执行的防抖函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> </span>func        回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;number&#125;</span>   </span>wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;boolean&#125;</span>  </span>immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args;</span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 延迟执行的情况下，函数会在延迟函数中执行</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, wait);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有创建延迟执行函数（later），就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later();</span><br><span class="line">      <span class="comment">// 如果是立即执行，调用函数</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则缓存参数和调用上下文</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = params;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = later();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">doc.onmousemove = debounce(todo, <span class="number">1000</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p><strong>节流是保证某个操作在一个时间段内只执行一次</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用时间戳，开始立即执行一次，最后不执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> initTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (now - initTime &gt; delay) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      initTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">doc.onmousemove = throttle(todo, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用定时器，开始不执行，最后执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">doc.onmousemove = throttle(todo, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖和节流都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 <code>wait</code>，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数 <code>wait</code>）调用函数。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://juejin.im/post/5b45fa596fb9a04fad3a0268" target="_blank" rel="noopener">虾扯蛋之函数防抖和节流</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;p&gt;在很多场景会频繁触发事件或频繁向后台发送请求，从而引发性能问题甚至导致浏览器奔溃，例如鼠标滚动事件，鼠标移动事件，input框模糊查询等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试题" scheme="https://hzu-zuoxiong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="性能优化" scheme="https://hzu-zuoxiong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Fastlane 打包 Flutter android 端</title>
    <link href="https://hzu-zuoxiong.github.io/2021/03/30/Fastlane-%E6%89%93%E5%8C%85-Flutter-android-%E7%AB%AF/"/>
    <id>https://hzu-zuoxiong.github.io/2021/03/30/Fastlane-%E6%89%93%E5%8C%85-Flutter-android-%E7%AB%AF/</id>
    <published>2021-03-30T18:06:00.000Z</published>
    <updated>2021-07-12T07:50:08.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fastlane-简述"><a href="#Fastlane-简述" class="headerlink" title="Fastlane 简述"></a>Fastlane 简述</h2><p><a href="http://docs.fastlane.tools/" target="_blank" rel="noopener">fastlane</a> 是自动化 iOS 和 Android 应用程序 Beta 部署和发布的最简单方法。🚀它可以处理所有繁琐的任务，例如生成屏幕截图，处理代码签名以及发布应用程序。Fastlane 的安装较为简单，这里就不做过多的介绍，具体操作步骤可参考链接:<br><a href="https://www.jianshu.com/p/ce16f4c63da7" target="_blank" rel="noopener">Fastlane 安装</a></p><a id="more"></a><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a><a href="https://docs.fastlane.tools/advanced/Appfile/#appfile" target="_blank" rel="noopener">Appfile</a></h4><p>存放着 AppleID 或者 BundleID 等一些 fastlane 需要用到的信息。基本上我们不需要改动这个文件的内容。它放到你项目下面的 ./fastlane 文件夹下面，默认生成的文件如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app_identifier("[[APP_IDENTIFIER]]") # The bundle identifier of your app</span></span><br><span class="line"><span class="comment"># apple_id("[[APPLE_ID]]") # Your Apple email address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For more information about the Appfile, see:</span></span><br><span class="line"><span class="comment">#     https://docs.fastlane.tools/advanced/#appfile</span></span><br><span class="line"><span class="comment"># Path to the json secret file - Follow https://docs.fastlane.tools/actions/supply/#setup to get one</span></span><br><span class="line">json_key_file(<span class="string">""</span>)</span><br><span class="line">package_name(<span class="string">"com.test.app"</span>)</span><br></pre></td></tr></table></figure><h4 id="FastFile"><a href="#FastFile" class="headerlink" title="FastFile"></a><a href="http://docs.fastlane.tools/advanced/Fastfile/#fastfile" target="_blank" rel="noopener">FastFile</a></h4><p>Fastfile 里面包含的块类型有四种：</p><ol><li>before_all 用于执行任务之前的操作，比如使用 cocopods 更新pod库</li><li>after_all 用于执行任务之后的操作，比如发送邮件，通知之前的</li><li>error 用于发生错误的操作</li><li>lane 定义用户的主要任务流程。例如打包 ipa ，执行测试等等</li></ol><h2 id="fastlane-打包实践"><a href="#fastlane-打包实践" class="headerlink" title="fastlane 打包实践"></a>fastlane 打包实践</h2><p>最近接手了公司的 Flutter 项目，因每次手动打 debug 包给测试较为繁琐，故而引入 fastlane 来实现用命令行自动打包上传至<a href="https://www.pgyer.com/" target="_blank" rel="noopener">蒲公英</a>。</p><p>下图为项目的目录图片，圈中的红框为 fastlane 的文件，fastlane 目录被我移至项目的根目录下，主要是为了方便将 android 和 ios 两端的代码写在一起。</p><p><img src="http://picbed.wuzuoxiong.top/20210330_fastlaneProjectDir.png" alt="Fastlane 项目目录"></p><p>具体代码实现：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fastfile</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:android</span> <span class="keyword">do</span></span><br><span class="line">  project_dir = <span class="string">'android/'</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">'Android: 执行打包过程'</span></span><br><span class="line">  private_lane <span class="symbol">:build</span> <span class="keyword">do</span> <span class="params">|options|</span></span><br><span class="line">    sh(<span class="string">'flutter clean'</span>)</span><br><span class="line">    gradle(<span class="symbol">task:</span> <span class="string">'clean'</span>, <span class="symbol">project_dir:</span> project_dir)</span><br><span class="line">    sh(<span class="string">'flutter pub get'</span>)</span><br><span class="line">    gradle(</span><br><span class="line">      <span class="symbol">task:</span> <span class="string">'assemble'</span>,</span><br><span class="line">      <span class="symbol">build_type:</span> options[<span class="symbol">:type</span>],</span><br><span class="line">      <span class="symbol">project_dir:</span> project_dir,</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  desc <span class="string">'Android: 打包上传蒲公英'</span></span><br><span class="line">  lane <span class="symbol">:pgy</span> <span class="keyword">do</span> <span class="params">|options|</span></span><br><span class="line">    apkType = options[<span class="symbol">:type</span>] <span class="params">||</span> <span class="string">'Release'</span></span><br><span class="line">    apkUrl = <span class="string">"<span class="subst">#&#123;File.expand_path(<span class="string">".."</span>, Dir.pwd)&#125;</span>/build/app/outputs/apk/<span class="subst">#&#123;apkType.downcase&#125;</span>/app-<span class="subst">#&#123;apkType.downcase&#125;</span>.apk"</span></span><br><span class="line">    build(<span class="symbol">type:</span> apkType)</span><br><span class="line">    pgyer(</span><br><span class="line">      <span class="symbol">api_key:</span> <span class="string">"abcd1234567890"</span>, </span><br><span class="line">      <span class="symbol">user_key:</span> <span class="string">"abcd1234567890"</span>,</span><br><span class="line">      <span class="symbol">apk:</span> apkUrl,</span><br><span class="line">      <span class="symbol">update_description:</span> options[<span class="symbol">:desc</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">'Android本地打包'</span></span><br><span class="line">  lane <span class="symbol">:buildApk</span> <span class="keyword">do</span> <span class="params">|options|</span></span><br><span class="line">    apkType = options[<span class="symbol">:type</span>] <span class="params">||</span> <span class="string">'Release'</span></span><br><span class="line">    build(<span class="symbol">type:</span> apkType)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gemfile</span></span><br><span class="line"></span><br><span class="line">source <span class="string">"https://rubygems.org"</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">'fastlane'</span></span><br><span class="line"></span><br><span class="line">plugins_path = File.join(File.dirname(__FILE_<span class="number">_</span>), <span class="string">'fastlane'</span>, <span class="string">'Pluginfile'</span>)</span><br><span class="line">eval_gemfile(plugins_path) <span class="keyword">if</span> File.exist?(plugins_path)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pluginfile</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">'fastlane-plugin-pgyer'</span></span><br><span class="line">gem <span class="string">'fastlane-plugin-versioning_android'</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令即可实现自动打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地打 android 包</span></span><br><span class="line">fastlane android buildApk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打 android 包上传至蒲公英，默认 Release 包</span></span><br><span class="line">fastlane android pgy</span><br><span class="line"><span class="comment"># 打 android 包上传至蒲公英，设置为 Debug 包</span></span><br><span class="line">fastlane android pgy <span class="built_in">type</span>:<span class="string">'Debug'</span></span><br><span class="line"><span class="comment"># 打 android 包上传至蒲公英，设置为 Debug 包，增加蒲公英上传描述语</span></span><br><span class="line">fastlane android pgy <span class="built_in">type</span>:<span class="string">'Debug'</span> desc:<span class="string">'fastlane 自动化测试'</span></span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="http://picbed.wuzuoxiong.top/20210330_fastlaneStart.png" alt><br><img src="http://picbed.wuzuoxiong.top/20210330_fastlaneEnd.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://flutter.dev/docs/deployment/cd" target="_blank" rel="noopener">Flutter 官网</a></li><li><a href="https://www.pgyer.com/doc/view/fastlane" target="_blank" rel="noopener">蒲公英 fastlane 文档</a></li><li><a href="https://github.com/shishirui/fastlane-plugin-pgyer" target="_blank" rel="noopener">pgyer github仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Fastlane-简述&quot;&gt;&lt;a href=&quot;#Fastlane-简述&quot; class=&quot;headerlink&quot; title=&quot;Fastlane 简述&quot;&gt;&lt;/a&gt;Fastlane 简述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://docs.fastlane.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fastlane&lt;/a&gt; 是自动化 iOS 和 Android 应用程序 Beta 部署和发布的最简单方法。🚀它可以处理所有繁琐的任务，例如生成屏幕截图，处理代码签名以及发布应用程序。Fastlane 的安装较为简单，这里就不做过多的介绍，具体操作步骤可参考链接:&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/ce16f4c63da7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fastlane 安装&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Flutter" scheme="https://hzu-zuoxiong.github.io/tags/Flutter/"/>
    
      <category term="Fastlane" scheme="https://hzu-zuoxiong.github.io/tags/Fastlane/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 打 release 包后运行闪退</title>
    <link href="https://hzu-zuoxiong.github.io/2021/03/29/Flutter-%E6%89%93-release-%E5%8C%85%E5%90%8E%E8%BF%90%E8%A1%8C%E9%97%AA%E9%80%80/"/>
    <id>https://hzu-zuoxiong.github.io/2021/03/29/Flutter-%E6%89%93-release-%E5%8C%85%E5%90%8E%E8%BF%90%E8%A1%8C%E9%97%AA%E9%80%80/</id>
    <published>2021-03-29T11:29:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近新需求改动了 Flutter 项目，该项目原先 Flutter 版本 1.9.1+hotfix.6，乘着需求改动，顺便将 Flutter 版本升级至 1.22.6。该需求改动仅为普通页面上的改动，在测试打包 debug 版本一切正常，然后在打包 android release 包正式上线后，发现 App 更新到新版本后会闪退，且百分百闪退。</p><a id="more"></a><p>为应对闪退问题，找到了以下几种方案：</p><ol><li>清除应用缓存</li><li>重装应用</li><li>关闭 android 代码混淆(Flutter 从 1.16.2 开始 ，默认开启了混淆的会遇到app闪退的情况，把它关闭即可)</li></ol><p>PS: 代码混淆是修改应用程序二进制文件的过程，以使人类更难理解。模糊处理将函数名和类名隐藏在已编译的Dart代码中，使攻击者很难对您的专有应用程序进行反向工程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android/app/build.grade</span></span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">    ...</span><br><span class="line">    release &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 关闭混淆</span></span><br><span class="line">        minifyEnabled <span class="literal">false</span> <span class="comment">//删除无用代码</span></span><br><span class="line">        shrinkResources <span class="literal">false</span> <span class="comment">//删除无用资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解是更新 App 之后本地存在代码混淆与未混淆两份代码，导致打开 App 无法确定运行哪一份代码导致的闪崩。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://flutter.cn/docs/deployment/obfuscate" target="_blank" rel="noopener">Flutter 代码混淆</a></li><li><a href="https://my.oschina.net/BingGo/blog/3437775" target="_blank" rel="noopener">Flutter 打包后运行闪退 release包闪退的解决办法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近新需求改动了 Flutter 项目，该项目原先 Flutter 版本 1.9.1+hotfix.6，乘着需求改动，顺便将 Flutter 版本升级至 1.22.6。该需求改动仅为普通页面上的改动，在测试打包 debug 版本一切正常，然后在打包 android release 包正式上线后，发现 App 更新到新版本后会闪退，且百分百闪退。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="https://hzu-zuoxiong.github.io/tags/android/"/>
    
      <category term="Flutter" scheme="https://hzu-zuoxiong.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Vue 路由钩子</title>
    <link href="https://hzu-zuoxiong.github.io/2021/03/15/vue-%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"/>
    <id>https://hzu-zuoxiong.github.io/2021/03/15/vue-%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/</id>
    <published>2021-03-15T14:52:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><h3 id="全局路由钩子"><a href="#全局路由钩子" class="headerlink" title="全局路由钩子"></a>全局路由钩子</h3><ol><li>router.beforeEach 全局前置守卫，进入路由之前。主要用于判断是否登录。</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置守卫，进入路由之后。只要用于跳转之后页面置顶。</li></ol><a id="more"></a><h3 id="单个路由独享钩子"><a href="#单个路由独享钩子" class="headerlink" title="单个路由独享钩子"></a>单个路由独享钩子</h3><p>可以为某些路由单独配置守卫</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'login'</span>,</span><br><span class="line">    component: login,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录页'</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="组件内钩子"><a href="#组件内钩子" class="headerlink" title="组件内钩子"></a>组件内钩子</h3><ol><li>beforeRouteEnter: 进入组件前触发。此时组件实例尚未创建，无法访问 this，需要传一个回调供 next 访问。</li><li>beforeRouteUpdate： 当前地址改变且该组件被复用时触发。如：动态参数路径 path/foo/:id，在 id 不一致时会渲染相同的组件，该钩子会被调用。可以访问组件实例。</li><li>beforeRouteLeave: 离开组件时触发。可以访问组件实例。</li></ol><h3 id="完整的路由导航解析流程（不包含其他声明周期）"><a href="#完整的路由导航解析流程（不包含其他声明周期）" class="headerlink" title="完整的路由导航解析流程（不包含其他声明周期）"></a>完整的路由导航解析流程（不包含其他声明周期）</h3><ol><li>触发进入其他路由。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局前置守卫 beforeEach。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter（路由独享守卫）。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局后置守卫 afterEach。</li><li>触发 DOM 更新。</li><li>调用组件内 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h3><p>路由导航和组件生命周期钩子结合起来的触发顺序。</p><ol><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局前置守卫 beforeEach。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter（路由独享守卫）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>调用全局后置守卫 afterEach。</li><li>beforeCreate: 组件生命周期，不能访问 this。</li><li>created: 组件生命周期，可以访问 this, 不能访问 dom。</li><li>beforeMount: 组件生命周期。</li><li>mounted：访问/操作 dom。</li><li>调用组件内 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;路由钩子&quot;&gt;&lt;a href=&quot;#路由钩子&quot; class=&quot;headerlink&quot; title=&quot;路由钩子&quot;&gt;&lt;/a&gt;路由钩子&lt;/h2&gt;&lt;h3 id=&quot;全局路由钩子&quot;&gt;&lt;a href=&quot;#全局路由钩子&quot; class=&quot;headerlink&quot; title=&quot;全局路由钩子&quot;&gt;&lt;/a&gt;全局路由钩子&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;router.beforeEach 全局前置守卫，进入路由之前。主要用于判断是否登录。&lt;/li&gt;
&lt;li&gt;router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用&lt;/li&gt;
&lt;li&gt;router.afterEach 全局后置守卫，进入路由之后。只要用于跳转之后页面置顶。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="面试题" scheme="https://hzu-zuoxiong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="vue" scheme="https://hzu-zuoxiong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>this、apply、call、bind</title>
    <link href="https://hzu-zuoxiong.github.io/2021/03/08/this%E3%80%81apply%E3%80%81call%E3%80%81bind/"/>
    <id>https://hzu-zuoxiong.github.io/2021/03/08/this%E3%80%81apply%E3%80%81call%E3%80%81bind/</id>
    <published>2021-03-08T23:19:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>在ES5中，this 永远指向最后调用它的那个对象。</p><a id="more"></a><p>举几个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// name: "Cherry",</span></span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例四：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f(); <span class="comment">// window调用该函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例五：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">    innerFn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h2 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h2><ul><li>使用 ES6 的箭头函数</li><li>函数内部使用变量保存 this 指向</li><li>使用 apply、call、bind</li><li>new 实例化一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的 this 始终指向函数定义时的 this，而非执行时。 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则 this 为 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'windowsName'</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'innerName'</span>,</span><br><span class="line">  func1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.func1();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2(); <span class="comment">// innerName</span></span><br></pre></td></tr></table></figure><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 apply</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// 此处省略</span></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.apply(a), <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2(); <span class="comment">// Cherry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// 此处省略</span></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.call(a), <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// 此处省略</span></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.bind(a)(), <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="call-与-apply-的区别"><a href="#call-与-apply-的区别" class="headerlink" title="call 与 apply 的区别"></a>call 与 apply 的区别</h4><ul><li>call 方法接收的是若干个参数</li><li>apply 方法接收的是参数数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'Cherry'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.call(a, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">b.apply(a, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h4><p>bind 方法返回一个改变了上下文 this 后的函数。而原函数中的 this 并没有被改变，依旧指向全局 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Dot'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dot = printName.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(dot); <span class="comment">// function () &#123; … &#125;</span></span><br><span class="line">dot(); <span class="comment">// Dot</span></span><br></pre></td></tr></table></figure><h4 id="模拟实现-apply、call、bind"><a href="#模拟实现-apply、call、bind" class="headerlink" title="模拟实现 apply、call、bind"></a>模拟实现 apply、call、bind</h4><h5 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h5><p>改变了 this 指向，让新的对象可以执行该函数。即，给新的对象添加一个函数，然后在执行完以后删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h5><p>与 call 的思路类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></span><br><span class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="模拟实现-bind"><a href="#模拟实现-bind" class="headerlink" title="模拟实现 bind"></a>模拟实现 bind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存原函数</span></span><br><span class="line">  <span class="keyword">var</span> context = [].shift.call(<span class="built_in">arguments</span>); <span class="comment">// 保存需要绑定的this上下文</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 保存剩余参数，转成数组形式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// [].slice.call(arguments) 为返回函数后调用传递的参数</span></span><br><span class="line">    self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this-的指向&quot;&gt;&lt;a href=&quot;#this-的指向&quot; class=&quot;headerlink&quot; title=&quot;this 的指向&quot;&gt;&lt;/a&gt;this 的指向&lt;/h2&gt;&lt;p&gt;在ES5中，this 永远指向最后调用它的那个对象。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试题" scheme="https://hzu-zuoxiong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="JS基础" scheme="https://hzu-zuoxiong.github.io/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>docker 基础知识</title>
    <link href="https://hzu-zuoxiong.github.io/2021/03/03/docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://hzu-zuoxiong.github.io/2021/03/03/docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-03T17:07:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>沙箱是一个虚拟系统程序，沙箱提供的环境相对于每一个运行的程序都是独立的，而且不会对现有的系统产生影响。</p><p>沙箱具有非常良好的独立性、隔离性，所以能够搭建一些具有高风险的软件进行测试。比如，你可以在沙箱里面运行一个病毒程序，也是安全的。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布，使用 docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速，一致地交付您的应用程序</li><li>响应式部署和扩展</li><li>在同一硬件上运行更多工作负载</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>docker 启动关闭</p><ul><li>第一行为 centos7.x 的命令</li><li>第二行为 centos6.x 的命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker 启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker 服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line">service docker restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">service docker stop</span><br></pre></td></tr></table></figure><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>我们要创建容器必须要基于镜像。当我们安装好 docker 之后，我们就可以直接在终端中通过 docker 命令从远程镜像仓库(Docker Hub)进行镜像的下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索 nginx 镜像资源</span></span><br><span class="line">docker search nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像过滤,搜索官方发布的 ngnix 镜像</span></span><br><span class="line">docker search --filter <span class="string">"is-official=true"</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像,从 docker Hub 中下载 nginx 镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已下载镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地镜像删除，即从本地仓库中删除镜像，可通过 rmi 命令进行删除，i 即 image</span></span><br><span class="line"><span class="comment"># 如果要删除的镜像被某个容器所使用，无论这个容器是否使用中，那么必须带上 -f 才能删除。</span></span><br><span class="line"><span class="comment"># 从本地仓库中删除nginx镜像</span></span><br><span class="line">docker rmi nginx</span><br><span class="line"><span class="comment"># 从本地仓库中强制删除vuenginx镜像</span></span><br><span class="line">docker rmi -f vuenginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像，即将 docker 中的本地镜像以 tar 压缩包的形式保存到宿主机中</span></span><br><span class="line"><span class="comment"># -o 即--output，指定保存后的镜像名称，之后的参数为 docker 中要被导出的镜像名</span></span><br><span class="line">docker save -o vuenginx.tar vuenginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载镜像，即将宿主机指定镜像压缩包加载到 docker 的本地镜像仓库中</span></span><br><span class="line"><span class="comment"># 注：压缩包的名称并不会影响加载后镜像的名称</span></span><br><span class="line">docker load -i ./images/vuenginx.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入镜像，即将宿主机指定镜像压缩包导入到 docker 的本地镜像仓库中</span></span><br><span class="line">docker import ./images/vuenginx.tar <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load 与 import 的区别</span></span><br><span class="line">import：丢弃了所有的历史记录和元数据信息，仅保存容器当时的快照状态。</span><br><span class="line">load：将保存完整记录，体积较大。</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="容器的基本操作"><a href="#容器的基本操作" class="headerlink" title="容器的基本操作"></a>容器的基本操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器，创建的容器不会被运行。</span></span><br><span class="line"><span class="comment"># 通过 created 命令创建的容器会处于 Created 状态，同名的容器不能重复创建。</span></span><br><span class="line"><span class="comment"># 基于 nginx 镜像创建名为nginxContainer容器</span></span><br><span class="line">docker create --name nginxContainer nginx</span><br><span class="line">docker create --name <span class="string">"nginxContainer"</span> nginx</span><br><span class="line">docker create --name=nginxContainer nginx</span><br><span class="line">docker create --name=<span class="string">"nginxContainer"</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器，即将创建好的容器启动起来，运行的容器会处于Up状态。</span></span><br><span class="line">docker restart nginxContainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行容器，即创建容器后立即运行起来</span></span><br><span class="line"><span class="comment"># -i 表示以交互模式运行容器，通常与 -t 同时使用;</span></span><br><span class="line"><span class="comment"># -t 表示为容器重新分配一个伪输入终端，通常与 -i 同时使用;</span></span><br><span class="line"><span class="comment"># -d 表示后台运行容器，并返回容器 ID</span></span><br><span class="line"><span class="comment"># --name 为容器指定名称，同 create 命令，若无指定，则自动生成。</span></span><br><span class="line">docker run -itd --name=container_name image_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 run 容器时，还可以传递一个 COMMAND，即在容器运行起来之后执行指定的命令。</span></span><br><span class="line"><span class="comment"># 如果这个命令是可以持续运行的，那么容器也可以进入到运行状态。</span></span><br><span class="line"><span class="comment"># 如果这个命令是执行完成后就结束的，那么容器也会随着命令的结束而进入停止状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器，即查看创建的容器信息。</span></span><br><span class="line"><span class="comment"># 查看运行中的容器信息</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="comment"># 查看所有容器信息包括已经停止运行的</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 查看运行中的容器信息</span></span><br><span class="line">docker container list</span><br><span class="line"><span class="comment"># 查看所有容器信息包括已经停止运行的</span></span><br><span class="line">docker container list -a</span><br><span class="line"><span class="comment"># 显示完整容器 ID，加上 --no-trunc 参数</span></span><br><span class="line">docker ps -a --no-trunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器，即让运行中的容器停止运行</span></span><br><span class="line">docker stop nginxContainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器，即让停止运行的的容器重新运行起来</span></span><br><span class="line">docker restart nginxContainer/[容器ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器，只能删除已经停止运行的容器</span></span><br><span class="line">docker rm nginxContainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，指的是进入容器的终端</span></span><br><span class="line"><span class="comment"># 注：必须带上 -i 和 -t。</span></span><br><span class="line"><span class="comment"># -t 只能进入到容器的终端界面，但无法进行命令交互。</span></span><br><span class="line"><span class="comment"># -i 只能够进行命令交互，但是没有终端界面。</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginxContainer bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器，即退出容器的终端界面，可以在容器终端中输入exit即可退出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交容器，即我们在容器中进行操作后将这些修改提交</span></span><br><span class="line"><span class="comment"># 提交后会创建一个新的镜像，我们可以基于这个新的镜像创建容器，创建的容器将会带上这些修改</span></span><br><span class="line">docker commit -m <span class="string">"create a new image"</span> nginxContainer new_nginxontainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出容器，即将容器进行导出成镜像压缩包</span></span><br><span class="line">docker <span class="built_in">export</span> vueApp &gt; vueApp.tar</span><br></pre></td></tr></table></figure><h4 id="容器的进阶操作"><a href="#容器的进阶操作" class="headerlink" title="容器的进阶操作"></a>容器的进阶操作</h4><p>容器的进阶操作主要是指 docker 容器和宿主机之间端口、文件的绑定，实现宿主机中修改能够立即同步到 docker 容器中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口映射，我们可以在运行容器的时候，将 docker 中的端口和宿主机的端口进行关系映射。</span></span><br><span class="line"><span class="comment"># 在执行 run 命令的时候，加上 -p 选项传入宿主机端口号:docker 容器端口号。</span></span><br><span class="line"><span class="comment"># 此时宿主机访问http://localhost:8080/，会被转发到 docker 的 80 端口上。</span></span><br><span class="line">docker run -itd --name nginxContainer -p 8080:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件挂载，即将宿主机中的某个文件或目录与docker容器中的某个文件或目录</span></span><br><span class="line"><span class="comment"># 在执行 run 命令的时候，加 -v 选项传入宿主机文件目录或文件(绝对路径):docker 容器目录或文件</span></span><br><span class="line"><span class="comment"># 注：宿主机目录必须是绝对路径，并且宿主机上该目录文件发生变化，则需重启容器。</span></span><br><span class="line">docker run -itd --name vueApp -p 8080:80 -v /**/**/<span class="built_in">test</span>-docker/dist:/usr/share/nginx/html/ vuenginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 宿主主机与docker容器之间文件拷贝，容器目录或文件需要指定容器名</span></span><br><span class="line">docker cp nginxContainer:/etc/nginx/conf.d/default.conf /**/**/target_dir/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>Dockerfile 是一个用来构建镜像的文本文件。一般分为四部分，基础镜像信息、维护者信息 镜像操作指令和容器启动时执行的指令，dockerfile 文件中可以通过 # 号进行注释。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FORM: 指定基础镜像名，必须是第一个指令，后续指令都是基于该镜像镜像操作。</span></span><br><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># MAINTAINER: 维护者信息，可选。</span></span><br><span class="line">MAINTAINER wuzuoxiong</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN: 构建镜像时执行的指令</span></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># dockerfile 的指令每执行一次都会在 docker 上新建一层。过多无意义的层，会造成镜像膨胀过大。</span></span><br><span class="line">RUN yum install wget  </span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span>  </span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line"><span class="comment"># 以上指令可简化为</span></span><br><span class="line">RUN yum install wget \  </span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz<span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \ </span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY: 将 dockerfile 文件所在目录下的本地文件或目录添加到容器中，压缩类型文件不会自动解压文件。</span></span><br><span class="line"><span class="comment"># 宿主机上的目录必须是相对于构建时所用的 dockerfile 所在的目录。</span></span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ADD: 同 COPY，但是其会自动解压文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD: 执行一条命令，该命令是在容器启动后调用。</span></span><br><span class="line"><span class="comment"># CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</span></span><br><span class="line"><span class="comment"># 如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</span></span><br><span class="line">CMD [<span class="string">"npm"</span>, <span class="string">"start"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ENTRYPOINT: 只允许一个，如果有多个，会发生覆盖，只执行最后一个。</span></span><br><span class="line"><span class="comment"># CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令</span></span><br><span class="line">ENTRYPOINT [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># LABEL: 用于为镜像添加元数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENV: 设置环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EXPOSE: 指定与外界交互的端口号，但并不会关联，需在运行容器时通过 -p 来关联这些端口号</span></span><br><span class="line">EXPOSE 80 443</span><br><span class="line"></span><br><span class="line"><span class="comment"># VOLUME: 用于指定容器运行时创建的匿名数据卷路径。</span></span><br><span class="line">VOLUME /foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR: 工作目录，类似于 cd 命令，会进入到指定目录下</span></span><br><span class="line">WORKDIR /usr/src/docker-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># USER: 用于指定执行后续命令的用户和用户组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARG: 指定构建参数，与 ENV 作用一致，不过作用域不一样。</span></span><br><span class="line"><span class="comment"># ARG 设置的环境变量仅对 Dockerfile 内有效，构建好的镜像内不存在此环境变量</span></span><br><span class="line">ARG NGINX_VERSION=1.15.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ONBUILD: 用于设置镜像触发器，延迟构建命令的执行。</span></span><br></pre></td></tr></table></figure><p>通过 dockerfile 文件构建镜像，可以通过 docker build 命令进行镜像的构建，-f 指定 dockerfile 文件的路径，-t 指定构建好的镜像名称，最后加一个.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 千万不要少了最后面的那个点</span></span><br><span class="line">docker build -f /path/to/dockerfile -t image_name .</span><br></pre></td></tr></table></figure><h2 id="部署-Portainer-项目"><a href="#部署-Portainer-项目" class="headerlink" title="部署 Portainer 项目"></a>部署 Portainer 项目</h2><p><a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">Portainer</a> 是一个开源、轻量级 Docker 管理用户界面，基于 Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索镜像</span></span><br><span class="line">docker search portainer/portainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run -d -p 9000:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name dockerAdmin portainer/portainer</span><br></pre></td></tr></table></figure><p>启动后访问，效果如图：<br><img src="http://picbed.wuzuoxiong.top/docker-basic.png" alt></p><p>我们可以在这个后台项目里面管理我们的 docker<br><img src="http://picbed.wuzuoxiong.top/docker-basic2.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://segmentfault.com/a/1190000022102310" target="_blank" rel="noopener">Docker基本使用以及实战部署Vue项目</a><br><a href="https://learnku.com/articles/48378" target="_blank" rel="noopener">重置 portainer 密码的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="https://hzu-zuoxiong.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】53.最大子序和</title>
    <link href="https://hzu-zuoxiong.github.io/2021/02/20/%E3%80%90LeetCode%E3%80%9153-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>https://hzu-zuoxiong.github.io/2021/02/20/%E3%80%90LeetCode%E3%80%9153-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2021-02-20T16:10:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><a id="more"></a><p><strong>示例 1：</strong></p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出：6</p><p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p><strong>示例 2：</strong></p><p>输入：nums = [1]</p><p>输出：1</p><p><strong>示例 3：</strong></p><p>输入：nums = [0]</p><p>输出：0</p><p><strong>示例 4：</strong></p><p>输入：nums = [-1]</p><p>输出：-1</p><p><strong>示例 5：</strong></p><p>输入：nums = [-100000]</p><p>输出：-100000</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4</span><br><span class="line">-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</span><br><span class="line"></span><br><span class="line">## 解题思路</span><br><span class="line"></span><br><span class="line">设定两个变量：</span><br><span class="line">1. 当前最大连续子序列和为 sum。</span><br><span class="line">2. 最大连续子序列和为 max, 初始默认为数组第一个数值。</span><br><span class="line"></span><br><span class="line">对数组 nums 进行循环遍历:</span><br><span class="line">1. 如果sum + num &gt; num, 则说明当前 num 对结果存在增益效果，则 sum 加上当前遍历的数字；</span><br><span class="line">2. 如果sum &lt; num, 则说明当前 num 对结果存在减益效果，则 sum 直接更新为当前遍历数字。</span><br><span class="line">3. 最大连续子序列和 max 为 sum 与 max 之间的最大值。</span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var maxSubArray &#x3D; function(nums) &#123;</span><br><span class="line">    let max &#x3D; nums[0];</span><br><span class="line">    </span><br><span class="line">    nums.reduce((sum, num) &#x3D;&gt; &#123;</span><br><span class="line">        sum &#x3D; Math.max(sum + num, num);</span><br><span class="line">        max &#x3D; Math.max(sum, max);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;);</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://hzu-zuoxiong.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>判断链表有环</title>
    <link href="https://hzu-zuoxiong.github.io/2021/02/19/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/"/>
    <id>https://hzu-zuoxiong.github.io/2021/02/19/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</id>
    <published>2021-02-19T17:25:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>有一个单向链表，链表当中有可能出现“环”，就像下图这样。如何判断出这个链表是有环链表？</p><a id="more"></a><p><img src="http://picbed.wuzuoxiong.top/listHasRing.png" alt></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-双重循环"><a href="#1-双重循环" class="headerlink" title="1. 双重循环"></a>1. 双重循环</h3><p>从第一个节点开始，依次遍历单链表的每一个节点，每遍历一个新节点，就从第一个节点重新遍历到新节点之前的所有节点，用新节点ID与之前的节点ID是否一致。若一致，则代表该链表有环；若不一致，则继续遍历下一个新节点。</p><p>该思路时间复杂度为O(N²)，空间复杂度O(1)。</p><h3 id="2-Hash记录"><a href="#2-Hash记录" class="headerlink" title="2. Hash记录"></a>2. Hash记录</h3><p>首先创建一个空的Hash集合，用于记录存储遍历过的节点。然后从第一个节点开始依次遍历，每遍历一个新节点，就用新节点和Hash集合当中存储的节点作比较。如果发现Hash集合中存在相同节点ID，则代表链表有环。</p><p>该思路时间复杂度为O(N)，空间复杂度O(N)。</p><h3 id="3-双倍移速"><a href="#3-双倍移速" class="headerlink" title="3. 双倍移速"></a>3. 双倍移速</h3><p>首先创建两个指针，指针1和指针2同时指向链表的第一个节点。然后让指针1每次移动一个节点，指针2每次移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环；如果不同，则两个指针继续移动。</p><p>该思路时间复杂度为O(N)，空间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;有一个单向链表，链表当中有可能出现“环”，就像下图这样。如何判断出这个链表是有环链表？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://hzu-zuoxiong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>node实现企业微信群机器人定时发送微博热搜</title>
    <link href="https://hzu-zuoxiong.github.io/2021/02/19/node%E5%AE%9E%E7%8E%B0%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C/"/>
    <id>https://hzu-zuoxiong.github.io/2021/02/19/node%E5%AE%9E%E7%8E%B0%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C/</id>
    <published>2021-02-19T15:26:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工(mo)作(yu)时，我们可以利用企业微信群机器人来推送消息，例如推送天气，项目告警等等。本文主要介绍利用企业微信群机器人来定时发送微博热搜。</p><p>项目 Github 地址：<a href="https://github.com/Hzu-zuoxiong/nodeEnterpriseWeChat" target="_blank" rel="noopener">nodeEnterpriseWeChat</a></p><a id="more"></a><h2 id="提取微博热搜数据"><a href="#提取微博热搜数据" class="headerlink" title="提取微博热搜数据"></a>提取微博热搜数据</h2><p>通过 superagent 和 cheerio 将微博热搜页面的数据提取出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHotSearchList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> weiboURL = <span class="string">'https://s.weibo.com'</span>;</span><br><span class="line">  <span class="keyword">const</span> weiboHotSearch = weiboURL + <span class="string">'/top/summary?cate=realtimehot'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    superagent.get(weiboHotSearch, (err, res) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) reject(<span class="string">'获取失败'</span>);</span><br><span class="line">      <span class="keyword">let</span> hotList = [];</span><br><span class="line">      <span class="keyword">const</span> $ = cheerio.load(res.text);</span><br><span class="line">      $(<span class="string">"#pl_top_realtimehot table tbody tr"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> $td = $(<span class="keyword">this</span>).children().eq(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">const</span> link = weiboURL + $td.find(<span class="string">"a"</span>).attr(<span class="string">"href"</span>);</span><br><span class="line">          <span class="keyword">const</span> text = $td.find(<span class="string">"a"</span>).text();</span><br><span class="line">          <span class="keyword">const</span> hotValue = $td.find(<span class="string">"span"</span>).text();</span><br><span class="line">          <span class="keyword">const</span> icon = $td.find(<span class="string">"img"</span>).attr(<span class="string">"src"</span>)</span><br><span class="line">            ? <span class="string">"https:"</span> + $td.find(<span class="string">"img"</span>).attr(<span class="string">"src"</span>)</span><br><span class="line">            : <span class="string">""</span>;</span><br><span class="line">          hotList.push(&#123;</span><br><span class="line">            index,</span><br><span class="line">            link,</span><br><span class="line">            text,</span><br><span class="line">            hotValue,</span><br><span class="line">            icon,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      hotList.length ? resolve(hotList) : reject(<span class="string">"errer"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过企业微信数据发送出去"><a href="#通过企业微信数据发送出去" class="headerlink" title="通过企业微信数据发送出去"></a>通过企业微信数据发送出去</h2><p>将微博数据封装成 markdown 字符串，将其发送出去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">"superagent"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处需要填写企业微信群机器人 WebHookURL</span></span><br><span class="line"><span class="keyword">const</span> webHookURL = <span class="string">'[企业微信 WebHookURL]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestfun</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resData = &#123;</span><br><span class="line">    <span class="string">"msgtype"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">    <span class="string">"markdown"</span>: &#123;</span><br><span class="line">      <span class="string">"content"</span>: msg,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  superagent.post(webHookURL)</span><br><span class="line">    .set(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">    .send(<span class="built_in">JSON</span>.stringify(resData))</span><br><span class="line">    .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'消息发送成功！'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sendWeiboData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> getHotSearchList();</span><br><span class="line">  <span class="keyword">var</span> sendMsg = <span class="string">'微博热搜榜前十：'</span>;</span><br><span class="line">  <span class="keyword">const</span> topTenArr = data.splice(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  topTenArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    sendMsg += <span class="string">`\n[<span class="subst">$&#123;item.index&#125;</span>. <span class="subst">$&#123;item.text&#125;</span>， 热度：<span class="subst">$&#123;item.hotValue&#125;</span>](<span class="subst">$&#123;item.link&#125;</span>)`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  requestfun(sendMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendWeiboData();</span><br></pre></td></tr></table></figure><h2 id="设置定时启动"><a href="#设置定时启动" class="headerlink" title="设置定时启动"></a>设置定时启动</h2><p>使用 node-schedule 将程序设置为每天9点半启动程序，使用自制的 mySetInterval 函数，进行每小时爬取微博数据，到20点时停止爬取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">'node-schedule'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">cb, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    cb();</span><br><span class="line">    <span class="keyword">const</span> curHours = <span class="keyword">new</span> <span class="built_in">Date</span>().getHours();</span><br><span class="line">    <span class="keyword">if</span> (curHours &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(fn, time)</span><br><span class="line">  &#125;;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作日每隔一小时爬取微博数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeiboDataInWorkDay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> M = myDate.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> D = myDate.getDate();</span><br><span class="line">  mySetInterval(sendWeiboData, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * *</span></span><br><span class="line"><span class="comment">// ┬ ┬ ┬ ┬ ┬ ┬</span></span><br><span class="line"><span class="comment">// │ │ │ │ │ |</span></span><br><span class="line"><span class="comment">// │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)</span></span><br><span class="line"><span class="comment">// │ │ │ │ └───── month (1 - 12)</span></span><br><span class="line"><span class="comment">// │ │ │ └────────── day of month (1 - 31)</span></span><br><span class="line"><span class="comment">// │ │ └─────────────── hour (0 - 23)</span></span><br><span class="line"><span class="comment">// │ └──────────────────── minute (0 - 59)</span></span><br><span class="line"><span class="comment">// └───────────────────────── second (0 - 59, OPTIONAL)</span></span><br><span class="line">schedule.scheduleJob(<span class="string">'0 30 9 * * *'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  getWeiboDataInWorkDay();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>因微博偶尔出现热点新闻导致热搜页面加载不出，进而使得程序报错中断，故而我们需要对其进行错误捕获，将其以日志的形式记录下来。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一生成writeStream</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStream</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fullFileName = path.join(__dirname, <span class="string">'./'</span>, <span class="string">'log'</span>, fileName)</span><br><span class="line">  <span class="keyword">const</span> writeStream = fs.createWriteStream(fullFileName, &#123;</span><br><span class="line">    flags: <span class="string">'a'</span> <span class="comment">//'a'为追加，'w'为覆盖</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> writeStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeLog</span>(<span class="params">writeStream, log</span>) </span>&#123;</span><br><span class="line">  writeStream.write(log + <span class="string">'\n'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抓取微博热搜页面，提取热搜数据json</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHotSearchList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> weiboURL = <span class="string">'https://s.weibo.com'</span>;</span><br><span class="line">  <span class="keyword">const</span> weiboHotSearch = weiboURL + <span class="string">'/top/summary?cate=realtimehot'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    superagent.get(weiboHotSearch, (err, res) =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hotList = [];</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> <span class="built_in">Error</span>(err);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 抓取微博热搜代码</span></span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">const</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">const</span> Y = myDate.getFullYear();</span><br><span class="line">        <span class="keyword">const</span> M = myDate.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> D = myDate.getDate();</span><br><span class="line">        <span class="keyword">const</span> curDay = Y + <span class="string">'-'</span> + M + <span class="string">'-'</span> + D;</span><br><span class="line">        <span class="keyword">const</span> fileName = curDay + <span class="string">'-'</span> + myDate.getTime() % <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">const</span> accessWriteStream = createWriteStream(<span class="string">`<span class="subst">$&#123;fileName&#125;</span>.log`</span>);</span><br><span class="line">        writeLog(accessWriteStream, <span class="string">`报错时间：\n<span class="subst">$&#123;curDay + <span class="string">' '</span> + myDate.toTimeString()&#125;</span>`</span>);</span><br><span class="line">        writeLog(accessWriteStream, <span class="string">`微博链接：\n<span class="subst">$&#123;weiboHotSearch&#125;</span>`</span>);</span><br><span class="line">        writeLog(accessWriteStream, <span class="string">`网页内容：\n<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(res)&#125;</span>`</span>);</span><br><span class="line">        writeLog(accessWriteStream, <span class="string">`报错信息：\n<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 企业微信通知查看报错日志</span></span><br><span class="line">        requestfun(<span class="string">`微博热搜数据爬取失败，请查看报错日志：<span class="subst">$&#123;fileName&#125;</span>.log`</span>);</span><br><span class="line">        <span class="comment">// 一分钟后重新爬取数据</span></span><br><span class="line">        setTimeout(getHotSearchList, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://work.weixin.qq.com/help?person_id=1&doc_id=13376" target="_blank" rel="noopener">企业微信群机器人官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常工(mo)作(yu)时，我们可以利用企业微信群机器人来推送消息，例如推送天气，项目告警等等。本文主要介绍利用企业微信群机器人来定时发送微博热搜。&lt;/p&gt;
&lt;p&gt;项目 Github 地址：&lt;a href=&quot;https://github.com/Hzu-zuoxiong/nodeEnterpriseWeChat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodeEnterpriseWeChat&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="node" scheme="https://hzu-zuoxiong.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Git cherry-pick</title>
    <link href="https://hzu-zuoxiong.github.io/2021/01/08/Git-cherry-pick/"/>
    <id>https://hzu-zuoxiong.github.io/2021/01/08/Git-cherry-pick/</id>
    <published>2021-01-08T18:08:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<p><code>cherry-pick</code> 可以将指定的提交应用于其他分支上，会在操作的分支上产生一次新的提交，新提交会有新的哈希值。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>如果提交来自于两个分支的合并的一个合并节点，那么 cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助文档</span></span><br><span class="line">git cherry-pick --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为提交的哈希值</span></span><br><span class="line">git cherry-pick &lt;commitHash&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移多次提交</span></span><br><span class="line">git cherry-pick &lt;commitHashA&gt; &lt;commitHashB&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为分支名，表示转移该分支的最新提交</span></span><br><span class="line">git cherry-pick &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移一系列提交</span></span><br><span class="line"><span class="comment"># commitHashA 必须早于 commitHashB 否则命令将失败但不会报错。</span></span><br><span class="line"><span class="comment"># 提交 commitHashA 将不会包含在 Cherry pick 中。</span></span><br><span class="line">git cherry-pick &lt;commitHashA&gt;..&lt;commitHashB&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要包含提交 commitHashA，可以使用下面的语法。</span></span><br><span class="line">git cherry-pick &lt;commitHashA&gt;^..&lt;commitHashB&gt;</span><br></pre></td></tr></table></figure><h2 id="操作子命令"><a href="#操作子命令" class="headerlink" title="操作子命令"></a>操作子命令</h2><ol><li>–continue 用户解决代码冲突后，将修改的文件重新加入暂存区（git add .），接着使用下面的命令，让 cherry pick 过程继续执行。</li><li>–abort 发生代码冲突后，放弃合并，回到操作前的样子。</li><li>–quit 发生代码冲突后，退出 cherry pick，但是不回到操作前的样子。</li></ol><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><ol><li>-e，–edit 打开外部编辑器，编辑提交信息。</li><li>-n，–no-commit 只更新工作区和暂存区，不产生新的提交。</li><li>-x  在提交信息的末尾追加一行 (cherry picked from commit …)，方便以后查到这个提交是如何产生的。</li><li>-s，–signoff 在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</li><li>-m parent-number , –mainline parent-number</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -m 配置项告诉 Git，应该采用哪个分支的变动。</span></span><br><span class="line"><span class="comment"># parent-number 是一个从1开始的整数，代表原始提交的父分支编号。</span></span><br><span class="line"><span class="comment"># cherry pick 采用提交 commitHash 来自编号1的父分支的变动</span></span><br><span class="line"><span class="comment"># 1号父分支是接受变动的分支（the branch being merged into）</span></span><br><span class="line"><span class="comment"># 2号父分支是作为变动来源的分支（the branch being merged from）</span></span><br><span class="line">git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html" target="_blank" rel="noopener">阮一峰 git cherry-pick 教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;cherry-pick&lt;/code&gt; 可以将指定的提交应用于其他分支上，会在操作的分支上产生一次新的提交，新提交会有新的哈希值。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="https://hzu-zuoxiong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试H5页面</title>
    <link href="https://hzu-zuoxiong.github.io/2020/12/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95H5%E9%A1%B5%E9%9D%A2/"/>
    <id>https://hzu-zuoxiong.github.io/2020/12/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95H5%E9%A1%B5%E9%9D%A2/</id>
    <published>2020-12-02T16:50:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们使用 Chrome 浏览器进行移动端模拟页面开发，但还是不可避免的还是需要使用到真机进行调试。下面列出 chrome 和 safari 浏览器的真机调试功能。</p><a id="more"></a><h2 id="chrome-真机调试"><a href="#chrome-真机调试" class="headerlink" title="chrome 真机调试"></a>chrome 真机调试</h2><h3 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li>使用 USB 数据线连接手机与电脑，或者直接在电脑上使用手机模拟器启动。</li><li>手机进入开发者模式，选中 USB 调试。</li><li>Chrome 浏览器输入 chrome://inspect/#devices 并选中 Discover USB devices 选项。</li><li>连接成功后，手机打开调试的页面，Chrome 页面会显示设备情况，点击 inspect 即可进入调试窗口。</li></ol><p><img src="//picbed.wuzuoxiong.top/20201202_mobileDevTool1.png" alt></p><p><img src="//picbed.wuzuoxiong.top/20201202_mobileDevTool2.png" alt></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用 Chrome inspect 调试时，需要从 <a href="https://chrome-devtools-frontend.appspot.com" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com</a> 加载资源，若界面空白，请科学上网。</p><h2 id="safari-真机调试"><a href="#safari-真机调试" class="headerlink" title="safari 真机调试"></a>safari 真机调试</h2><h3 id="调试步骤-1"><a href="#调试步骤-1" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li>使用数据线连接 iPhone 与 mac，或者使用 xcode 启动模拟器。</li><li>iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器）</li><li>Mac 打开 Safari 浏览器调试（Safari菜单栏 -&gt; 开发 -&gt; 设备名 -&gt; 选择调试页面）。若 Safari 菜单栏无“开发”选项，可以在Safari菜单栏进行设置（Safari 浏览器 -&gt; 偏好设置 -&gt; 高级 -&gt; 勾选在菜单栏中显示“开发”菜单）<br><img src="//picbed.wuzuoxiong.top/20201202_mobileDevTool3.png" alt></li></ol><p><img src="//picbed.wuzuoxiong.top/20201202_mobileDevTool4.png" alt></p><p><img src="//picbed.wuzuoxiong.top/20201202_mobileDevTool5.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000018613578" target="_blank" rel="noopener">9102了，你还不会移动端真机调试？</a></li><li><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html" target="_blank" rel="noopener">Safari Web Inspector Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时我们使用 Chrome 浏览器进行移动端模拟页面开发，但还是不可避免的还是需要使用到真机进行调试。下面列出 chrome 和 safari 浏览器的真机调试功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="调试" scheme="https://hzu-zuoxiong.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用iframe宽度超出屏幕</title>
    <link href="https://hzu-zuoxiong.github.io/2020/11/30/iOS%E4%BD%BF%E7%94%A8iframe%E5%AE%BD%E5%BA%A6%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95/"/>
    <id>https://hzu-zuoxiong.github.io/2020/11/30/iOS%E4%BD%BF%E7%94%A8iframe%E5%AE%BD%E5%BA%A6%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95/</id>
    <published>2020-11-30T17:41:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当我们给 iframe 设置宽度 100% 时，我们希望其中的内容是响应式的，不应该出现滚动条。但是 iOS 下存在问题，width: 100% 似乎被浏览器的默认设置覆盖了，无法得到应用。效果如下图所示：</p><a id="more"></a><p><img src="//picbed.wuzuoxiong.top/20201130_iosIframe1.png" alt></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>给iframe设置属性scrolling=’no’</li><li>给iframe设置样式：width: 1px; min-width: 100%; *width: 100%;</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- iOS13 以上版本无需设置 scrolling="no" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">src</span>=<span class="string">"https://juejin.im/timeline"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe&#123;</span><br><span class="line">  min-width: <span class="number">100</span>%;</span><br><span class="line">  *width: <span class="number">100</span>%; <span class="comment">// css定义里 * 后的字段只有IE浏览器能识别</span></span><br><span class="line">  width: <span class="number">1</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果：</p><p><img src="//picbed.wuzuoxiong.top/20201130_iosIframe2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;当我们给 iframe 设置宽度 100% 时，我们希望其中的内容是响应式的，不应该出现滚动条。但是 iOS 下存在问题，width: 100% 似乎被浏览器的默认设置覆盖了，无法得到应用。效果如下图所示：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="WKWebView" scheme="https://hzu-zuoxiong.github.io/tags/WKWebView/"/>
    
      <category term="ios" scheme="https://hzu-zuoxiong.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】198.打家劫舍</title>
    <link href="https://hzu-zuoxiong.github.io/2020/11/25/%E3%80%90LeetCode%E3%80%91198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://hzu-zuoxiong.github.io/2020/11/25/%E3%80%90LeetCode%E3%80%91198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2020-11-25T10:53:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><a id="more"></a><p><strong>示例 1：</strong></p><p>输入：[1,2,3,1]</p><p>输出：4</p><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>示例 2：</strong></p><p>输入：[2,7,9,3,1]</p><p>输出：12</p><p>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目可以简化理解为：因不可连续取值，所以第n个值是否可取存在两种情况，即取或不取。而决定是否取值则相当于比较两种情况的最大值</p><ol><li>[0, … , n-1] 的最大值</li><li>[0, … , n-2] 的最大值加上第n个值</li></ol><p>dp 数组为存放最大值数组，dp[i]代表前 i-1 个数的最大值。如下图所示：</p><p><img src="//picbed.wuzuoxiong.top/20201124_leetcode198.png" alt></p><p>则最后的动态方程式：dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1])</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="https://hzu-zuoxiong.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://hzu-zuoxiong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Android 9 http error</title>
    <link href="https://hzu-zuoxiong.github.io/2020/11/03/Android-9-http-error/"/>
    <id>https://hzu-zuoxiong.github.io/2020/11/03/Android-9-http-error/</id>
    <published>2020-11-03T11:07:00.000Z</published>
    <updated>2021-07-12T07:50:08.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><blockquote><p>为保证用户数据和设备的安全，Google 针对下一代 Android 系统 (Android 9) 的应用程序，将要求默认使用加密连接，安卓系统将在 app 中默认阻止所有HTTP流量，任何需要 HTTP 连接的内容必须提交特殊声明。</p></blockquote><a id="more"></a><p>在 Android 9 以上版本使用进行 http 请求会出现以下异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W&#x2F;System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted</span><br><span class="line"></span><br><span class="line">java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy</span><br></pre></td></tr></table></figure><p>在 Android 9 以上系统，如果 app 使用的是 http 网络请求，则会导致 app 无法进行网络请求，https 则不会受影响。同样地，如果 app 嵌套了webview，webview 也只能使用 https 请求。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><ol><li><p>在 app/src/main/res/xml 路径下创建一个 network_security_config.xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">  &lt;base-config cleartextTrafficPermitted&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;network-security-config&gt;0</span><br></pre></td></tr></table></figure></li><li><p>在 AndroidManifest.xml 文件下的 application 标签添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">...</span><br><span class="line"> android:networkSecurityConfig&#x3D;&quot;@xml&#x2F;network_security_config&quot;</span><br><span class="line">...</span><br><span class="line">    &#x2F;&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>直接在 AndroidManifest.xml 文件下的 application 标签添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">...</span><br><span class="line"> android:usesCleartextTraffic&#x3D;&quot;true&quot;</span><br><span class="line">...</span><br><span class="line">    &#x2F;&gt;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/shanshan_1117/article/details/89394652" target="_blank" rel="noopener">解决Android P/9.0 系统 网络请求错误</a> </li><li><a href="https://blog.csdn.net/gengkui9897/article/details/82863966" target="_blank" rel="noopener">Android高版本联网失败报错:Cleartext HTTP traffic to xxx not permitted解决方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题原因&quot;&gt;&lt;a href=&quot;#问题原因&quot; class=&quot;headerlink&quot; title=&quot;问题原因&quot;&gt;&lt;/a&gt;问题原因&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为保证用户数据和设备的安全，Google 针对下一代 Android 系统 (Android 9) 的应用程序，将要求默认使用加密连接，安卓系统将在 app 中默认阻止所有HTTP流量，任何需要 HTTP 连接的内容必须提交特殊声明。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="https://hzu-zuoxiong.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>iOS上input框无法失焦</title>
    <link href="https://hzu-zuoxiong.github.io/2020/10/11/ios%E4%B8%8Ainput%E6%A1%86%E6%97%A0%E6%B3%95%E5%A4%B1%E7%84%A6/"/>
    <id>https://hzu-zuoxiong.github.io/2020/10/11/ios%E4%B8%8Ainput%E6%A1%86%E6%97%A0%E6%B3%95%E5%A4%B1%E7%84%A6/</id>
    <published>2020-10-11T18:15:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>使用 ios 的 WKWebView 填写表单时，点击除 input 框外其他地方，无任何反应，手机软键盘无法自动隐藏，需要通过其他控件触发页面跳转才能将软键盘收起。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然点击其他地方无法使 input 框失焦，我们则对其进行手动失焦处理，让软键盘自动收起</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="//picbed.wuzuoxiong.top/20201106_keyboard.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复现过程&quot;&gt;&lt;a href=&quot;#复现过程&quot; class=&quot;headerlink&quot; title=&quot;复现过程&quot;&gt;&lt;/a&gt;复现过程&lt;/h2&gt;&lt;p&gt;使用 ios 的 WKWebView 填写表单时，点击除 input 框外其他地方，无任何反应，手机软键盘无法自动隐藏，需要通过其他控件触发页面跳转才能将软键盘收起。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="WKWebView" scheme="https://hzu-zuoxiong.github.io/tags/WKWebView/"/>
    
      <category term="ios" scheme="https://hzu-zuoxiong.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli3 创建多项目工程</title>
    <link href="https://hzu-zuoxiong.github.io/2020/07/06/vue-cli3-%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/"/>
    <id>https://hzu-zuoxiong.github.io/2020/07/06/vue-cli3-%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B/</id>
    <published>2020-07-06T12:19:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>一个 vue 项目集成多个子系统，不同的系统之间可共用同一套 utils 类、静态资源、axios 配置以及公共组件等。</p><a id="more"></a><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li>在项目根目录下新建 config 文件夹，新建一个 projectsConfig.js 文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const isOnline &#x3D; process.env.npm_config_env &#x3D;&#x3D;&#x3D; &#39;online&#39;;</span><br><span class="line"></span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">  projectA: &#123;</span><br><span class="line">    pages: &#123;</span><br><span class="line">      index: &#123;</span><br><span class="line">        entry: &quot;src&#x2F;modules&#x2F;projectA&#x2F;main.js&quot;,</span><br><span class="line">        template: &quot;public&#x2F;index.html&quot;,</span><br><span class="line">        filename: &quot;index.html&quot;,</span><br><span class="line">        &#x2F;&#x2F; 可以为模板 html 文件添加变量</span><br><span class="line">        DEBUG: !isOnline,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  projectB: &#123;</span><br><span class="line">    pages: &#123;</span><br><span class="line">      index: &#123;</span><br><span class="line">        entry: &quot;src&#x2F;modules&#x2F;projectB&#x2F;main.js&quot;,</span><br><span class="line">        template: &quot;public&#x2F;index.html&quot;,</span><br><span class="line">        filename: &quot;index.html&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; config;</span><br></pre></td></tr></table></figure><h3 id="模板-html-文件添加变量示例"><a href="#模板-html-文件添加变量示例" class="headerlink" title="模板 html 文件添加变量示例"></a>模板 html 文件添加变量示例</h3><p>DEBUG 模式下，为项目添加 eruda 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&lt;%&#x3D; BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;</span><br><span class="line">      &lt;strong&gt;We&#39;re sorry but &lt;%&#x3D; htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">    &lt;% if(htmlWebpackPlugin.options.DEBUG) &#123; %&gt;</span><br><span class="line">      &lt;script crossorigin src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;eruda&#x2F;1.5.4&#x2F;eruda.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        eruda.init();</span><br><span class="line">      &lt;&#x2F;script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li>在根目录下新建 vue.config.js 文件，修改 webpack 配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; require(&quot;.&#x2F;config&#x2F;projectsConfig.js&quot;); &#x2F;&#x2F; 引入子系统运行打包配置</span><br><span class="line">const projectName &#x3D; process.env.PROJECT_NAME; &#x2F;&#x2F; 获取package.json中scripts配置的变量</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...config[projectName],</span><br><span class="line">  publicPath: &quot;&quot;,</span><br><span class="line">  productionSourceMap: false, &#x2F;&#x2F; 生产禁止显示源代码</span><br><span class="line">  outputDir: &quot;dist&#x2F;&quot; + projectName + &quot;&#x2F;&quot;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: 8085, &#x2F;&#x2F; 端口地址</span><br><span class="line">    open: false, &#x2F;&#x2F; 是否自动打开浏览器页面</span><br><span class="line">    host: &quot;0.0.0.0&quot;, &#x2F;&#x2F; 指定使用一个 host，默认是 localhost</span><br><span class="line">    https: false, &#x2F;&#x2F; 使用https提供服务</span><br><span class="line">    disableHostCheck: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在 package.json 文件配置子系统打包命令,运行命令即可打包或运行指定子系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev:projectA&quot;: &quot;cross-env PROJECT_NAME&#x3D;projectA vue-cli-service serve&quot;,</span><br><span class="line">  &quot;dev:projectB&quot;: &quot;cross-env PROJECT_NAME&#x3D;projectB vue-cli-service serve&quot;,</span><br><span class="line">  &quot;build:projectA&quot;: &quot;cross-env PROJECT_NAME&#x3D;projectA vue-cli-service build&quot;,</span><br><span class="line">  &quot;build:projectB&quot;: &quot;cross-env PROJECT_NAME&#x3D;projectB vue-cli-service build&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>问题：若报”cross-env不是内部或外部命令，也不是可运行的程序”的错误<br>解决：运行 npm i cross-env –save-dev</p><ul><li>最终项目目录结构</li></ul><p><img src="//picbed.wuzuoxiong.top/20201106_vue3.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_35321405/article/details/102951883" target="_blank" rel="noopener">vue-cli3多项目整合到一个项目中维护打包发布</a> </li><li><a href="https://blog.csdn.net/Hampton_Chen/article/details/88931567" target="_blank" rel="noopener">vue-cli3创建多项目工程，支持分项目编译打包到相应文件夹中</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;一个 vue 项目集成多个子系统，不同的系统之间可共用同一套 utils 类、静态资源、axios 配置以及公共组件等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue" scheme="https://hzu-zuoxiong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>windows VMware 安装 MacOS10.15</title>
    <link href="https://hzu-zuoxiong.github.io/2020/06/29/windows-VMware-%E5%AE%89%E8%A3%85-MacOS/"/>
    <id>https://hzu-zuoxiong.github.io/2020/06/29/windows-VMware-%E5%AE%89%E8%A3%85-MacOS/</id>
    <published>2020-06-29T16:48:00.000Z</published>
    <updated>2021-07-12T07:50:08.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载 unlocker VMware 和 MacOS。</p><p>下载链接：<a href="https://pan.baidu.com/s/1Fm-pvLjBxFCsWFMKIJuczg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Fm-pvLjBxFCsWFMKIJuczg</a> ，提取码：whi0</p><h2 id="VMware-添加-MacOS-支持"><a href="#VMware-添加-MacOS-支持" class="headerlink" title="VMware 添加 MacOS 支持"></a>VMware 添加 MacOS 支持</h2><p>在 unlocker 文件夹中找到 win-install.cmd 右键选择管理员权限允许，脚本运行完成之后直接退出。</p><p>此时再打开 VMware 新建虚拟机时增加了 MacOS 选项</p><a id="more"></a><h2 id="配置虚拟机选项"><a href="#配置虚拟机选项" class="headerlink" title="配置虚拟机选项"></a>配置虚拟机选项</h2><ol><li>在安装虚拟机时选择稍后安装操作系统选项</li><li>在选择操作系统里选择 MacOS10.14，虽然安装的是10.15，但并不影响<br><img src="//picbed.wuzuoxiong.top/20201106_vm_mac1.png" alt></li><li>配置完成之后先不启动虚拟机，进入虚拟机目录找到’虚拟机名称.vmx’文件，使用记事本打开<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在VMX文件结尾添加此段代码并保存，请注意双引号是英文半角的</span><br><span class="line">smc.version &#x3D; &quot;0&quot;</span><br></pre></td></tr></table></figure></li></ol><p>PS：</p><p>内存、内核数、磁盘数尽可能选择大数值，具体配置依赖自身电脑而定。<br>我设置的是双核6G内存80G磁盘容量</p><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><ol><li>开启虚拟机，若出现苹果标志但没有进度条或无法显示安装步骤，请将虚拟机关机</li><li>点击编辑虚拟机设置，在右侧客户机操作系统里选择 windows x64</li><li>设置成功后再次开机，若出现苹果标志但没有进度条，编辑虚拟机设置，在右侧客户机操作系统里选择 Mac OS10.14，然后重复 1~3 的操作。<br><img src="//picbed.wuzuoxiong.top/20201106_vm_mac2.png" alt></li><li>成功出现进度条后即可进行正常的安装。</li></ol><p>参考链接：<br><a href="https://www.landiannews.com/archives/66114.html" target="_blank" rel="noopener">https://www.landiannews.com/archives/66114.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;下载 unlocker VMware 和 MacOS。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;https://pan.baidu.com/s/1Fm-pvLjBxFCsWFMKIJuczg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1Fm-pvLjBxFCsWFMKIJuczg&lt;/a&gt; ，提取码：whi0&lt;/p&gt;
&lt;h2 id=&quot;VMware-添加-MacOS-支持&quot;&gt;&lt;a href=&quot;#VMware-添加-MacOS-支持&quot; class=&quot;headerlink&quot; title=&quot;VMware 添加 MacOS 支持&quot;&gt;&lt;/a&gt;VMware 添加 MacOS 支持&lt;/h2&gt;&lt;p&gt;在 unlocker 文件夹中找到 win-install.cmd 右键选择管理员权限允许，脚本运行完成之后直接退出。&lt;/p&gt;
&lt;p&gt;此时再打开 VMware 新建虚拟机时增加了 MacOS 选项&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MacOS" scheme="https://hzu-zuoxiong.github.io/tags/MacOS/"/>
    
      <category term="VMware" scheme="https://hzu-zuoxiong.github.io/tags/VMware/"/>
    
  </entry>
  
</feed>
